{"file":"asyncData-DzZ9Lhv5.js","mappings":"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","names":[],"sources":["../../../../../../nuxt/dist/app/composables/asyncData.js"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, queuePostFlushCb, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\r\nimport { debounce } from \"perfect-debounce\";\r\nimport { hash } from \"ohash\";\r\nimport { useNuxtApp } from \"../nuxt.js\";\r\nimport { getUserCaller, toArray } from \"../utils.js\";\r\nimport { clientOnlySymbol } from \"../components/client-only.js\";\r\nimport { createError } from \"./error.js\";\r\nimport { onNuxtReady } from \"./ready.js\";\r\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData } from \"#build/nuxt.config.mjs\";\r\nexport function useAsyncData(...args) {\r\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\r\n  if (_isAutoKeyNeeded(args[0], args[1])) {\r\n    args.unshift(autoKey);\r\n  }\r\n  let [_key, _handler, options = {}] = args;\r\n  let keyChanging = false;\r\n  const key = computed(() => toValue(_key));\r\n  if (typeof key.value !== \"string\") {\r\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\r\n  }\r\n  if (typeof _handler !== \"function\") {\r\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\r\n  }\r\n  const nuxtApp = useNuxtApp();\r\n  options.server ??= true;\r\n  options.default ??= getDefault;\r\n  options.getCachedData ??= getDefaultCachedData;\r\n  options.lazy ??= false;\r\n  options.immediate ??= true;\r\n  options.deep ??= asyncDataDefaults.deep;\r\n  options.dedupe ??= \"cancel\";\r\n  const functionName = options._functionName || \"useAsyncData\";\r\n  const currentData = nuxtApp._asyncData[key.value];\r\n  if (import.meta.dev && currentData) {\r\n    const warnings = [];\r\n    const values = createHash(_handler, options);\r\n    if (values.handler !== currentData._hash?.handler) {\r\n      warnings.push(`different handler`);\r\n    }\r\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\r\n      if (values[opt] !== currentData._hash[opt]) {\r\n        warnings.push(`different \\`${opt}\\` option`);\r\n      }\r\n    }\r\n    if (currentData._default.toString() !== options.default.toString()) {\r\n      warnings.push(`different \\`default\\` value`);\r\n    }\r\n    if (options.deep && isShallow(currentData.data)) {\r\n      warnings.push(`mismatching \\`deep\\` option`);\r\n    }\r\n    if (warnings.length) {\r\n      const caller = getUserCaller();\r\n      const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\r\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\r\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\r\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\r\n    }\r\n  }\r\n  function createInitialFetch() {\r\n    const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\r\n    if (!nuxtApp._asyncData[key.value]?._init) {\r\n      initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\r\n      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\r\n    }\r\n    return () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\r\n  }\r\n  const initialFetch = createInitialFetch();\r\n  const asyncData = nuxtApp._asyncData[key.value];\r\n  asyncData._deps++;\r\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\r\n  if (import.meta.server && fetchOnServer && options.immediate) {\r\n    const promise = initialFetch();\r\n    if (getCurrentInstance()) {\r\n      onServerPrefetch(() => promise);\r\n    } else {\r\n      nuxtApp.hook(\"app:created\", async () => {\r\n        await promise;\r\n      });\r\n    }\r\n  }\r\n  if (import.meta.client) {\r\n    let unregister = function(key2) {\r\n      const data = nuxtApp._asyncData[key2];\r\n      if (data?._deps) {\r\n        data._deps--;\r\n        if (data._deps === 0) {\r\n          data?._off();\r\n        }\r\n      }\r\n    };\r\n    const instance = getCurrentInstance();\r\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\r\n      instance.sp = [];\r\n    }\r\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\r\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/4.x/getting-started/data-fetching`);\r\n    }\r\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\r\n      instance._nuxtOnBeforeMountCbs = [];\r\n      const cbs = instance._nuxtOnBeforeMountCbs;\r\n      onBeforeMount(() => {\r\n        cbs.forEach((cb) => {\r\n          cb();\r\n        });\r\n        cbs.splice(0, cbs.length);\r\n      });\r\n      onUnmounted(() => cbs.splice(0, cbs.length));\r\n    }\r\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\r\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value !== void 0)) {\r\n      if (pendingWhenIdle) {\r\n        asyncData.pending.value = false;\r\n      }\r\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\r\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\r\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\r\n    } else if (options.immediate && asyncData.status.value !== \"success\") {\r\n      initialFetch();\r\n    }\r\n    const hasScope = getCurrentScope();\r\n    const unsubKeyWatcher = watch(key, (newKey, oldKey) => {\r\n      if ((newKey || oldKey) && newKey !== oldKey) {\r\n        keyChanging = true;\r\n        const hadData = nuxtApp._asyncData[oldKey]?.data.value !== void 0;\r\n        const wasRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\r\n        const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\r\n        if (!nuxtApp._asyncData[newKey]?._init) {\r\n          let initialValue;\r\n          if (oldKey && hadData) {\r\n            initialValue = nuxtApp._asyncData[oldKey].data.value;\r\n          } else {\r\n            initialValue = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\r\n            initialFetchOptions.cachedData = initialValue;\r\n          }\r\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialValue);\r\n        }\r\n        nuxtApp._asyncData[newKey]._deps++;\r\n        if (oldKey) {\r\n          unregister(oldKey);\r\n        }\r\n        if (options.immediate || hadData || wasRunning) {\r\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions);\r\n        }\r\n        queuePostFlushCb(() => {\r\n          keyChanging = false;\r\n        });\r\n      }\r\n    }, { flush: \"sync\" });\r\n    const unsubParamsWatcher = options.watch ? watch(options.watch, () => {\r\n      if (keyChanging) {\r\n        return;\r\n      }\r\n      asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\r\n    }) : () => {\r\n    };\r\n    if (hasScope) {\r\n      onScopeDispose(() => {\r\n        unsubKeyWatcher();\r\n        unsubParamsWatcher();\r\n        unregister(key.value);\r\n      });\r\n    }\r\n  }\r\n  const asyncReturn = {\r\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\r\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\r\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\r\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\r\n    refresh: (...args2) => {\r\n      if (!nuxtApp._asyncData[key.value]?._init) {\r\n        const initialFetch2 = createInitialFetch();\r\n        return initialFetch2();\r\n      }\r\n      return nuxtApp._asyncData[key.value].execute(...args2);\r\n    },\r\n    execute: (...args2) => asyncReturn.refresh(...args2),\r\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\r\n  };\r\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\r\n  Object.assign(asyncDataPromise, asyncReturn);\r\n  return asyncDataPromise;\r\n}\r\nfunction writableComputedRef(getter) {\r\n  return computed({\r\n    get() {\r\n      return getter()?.value;\r\n    },\r\n    set(value) {\r\n      const ref2 = getter();\r\n      if (ref2) {\r\n        ref2.value = value;\r\n      }\r\n    }\r\n  });\r\n}\r\nexport function useLazyAsyncData(...args) {\r\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\r\n  if (_isAutoKeyNeeded(args[0], args[1])) {\r\n    args.unshift(autoKey);\r\n  }\r\n  const [key, handler, options = {}] = args;\r\n  if (import.meta.dev) {\r\n    options._functionName ||= \"useLazyAsyncData\";\r\n  }\r\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\r\n}\r\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\r\n  if (typeof keyOrFetcher === \"string\") {\r\n    return false;\r\n  }\r\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\r\n    return false;\r\n  }\r\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nexport function useNuxtData(key) {\r\n  const nuxtApp = useNuxtApp();\r\n  if (!(key in nuxtApp.payload.data)) {\r\n    nuxtApp.payload.data[key] = void 0;\r\n  }\r\n  if (nuxtApp._asyncData[key]) {\r\n    const data = nuxtApp._asyncData[key];\r\n    data._deps++;\r\n    if (getCurrentScope()) {\r\n      onScopeDispose(() => {\r\n        data._deps--;\r\n        if (data._deps === 0) {\r\n          data?._off();\r\n        }\r\n      });\r\n    }\r\n  }\r\n  return {\r\n    data: computed({\r\n      get() {\r\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\r\n      },\r\n      set(value) {\r\n        if (nuxtApp._asyncData[key]) {\r\n          nuxtApp._asyncData[key].data.value = value;\r\n        } else {\r\n          nuxtApp.payload.data[key] = value;\r\n        }\r\n      }\r\n    })\r\n  };\r\n}\r\nexport async function refreshNuxtData(keys) {\r\n  if (import.meta.server) {\r\n    return Promise.resolve();\r\n  }\r\n  await new Promise((resolve) => onNuxtReady(resolve));\r\n  const _keys = keys ? toArray(keys) : void 0;\r\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\r\n}\r\nexport function clearNuxtData(keys) {\r\n  const nuxtApp = useNuxtApp();\r\n  const _allKeys = Object.keys(nuxtApp.payload.data);\r\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\r\n  for (const key of _keys) {\r\n    clearNuxtDataByKey(nuxtApp, key);\r\n  }\r\n}\r\nfunction clearNuxtDataByKey(nuxtApp, key) {\r\n  if (key in nuxtApp.payload.data) {\r\n    nuxtApp.payload.data[key] = void 0;\r\n  }\r\n  if (key in nuxtApp.payload._errors) {\r\n    nuxtApp.payload._errors[key] = void 0;\r\n  }\r\n  if (nuxtApp._asyncData[key]) {\r\n    nuxtApp._asyncData[key].data.value = unref(nuxtApp._asyncData[key]._default());\r\n    nuxtApp._asyncData[key].error.value = void 0;\r\n    if (pendingWhenIdle) {\r\n      nuxtApp._asyncData[key].pending.value = false;\r\n    }\r\n    nuxtApp._asyncData[key].status.value = \"idle\";\r\n  }\r\n  if (key in nuxtApp._asyncDataPromises) {\r\n    if (nuxtApp._asyncDataPromises[key]) {\r\n      nuxtApp._asyncDataPromises[key].cancelled = true;\r\n    }\r\n    nuxtApp._asyncDataPromises[key] = void 0;\r\n  }\r\n}\r\nfunction pick(obj, keys) {\r\n  const newObj = {};\r\n  for (const key of keys) {\r\n    newObj[key] = obj[key];\r\n  }\r\n  return newObj;\r\n}\r\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\r\n  nuxtApp.payload._errors[key] ??= void 0;\r\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\r\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\r\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\r\n    if (value) {\r\n      return value;\r\n    }\r\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\r\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\r\n    return promise;\r\n  };\r\n  const _ref = options.deep ? ref : shallowRef;\r\n  const hasCachedData = initialCachedData !== void 0;\r\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\r\n    if (!keys || keys.includes(key)) {\r\n      await asyncData.execute({ cause: \"refresh:hook\" });\r\n    }\r\n  });\r\n  const asyncData = {\r\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\r\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\r\n    error: toRef(nuxtApp.payload._errors, key),\r\n    status: shallowRef(\"idle\"),\r\n    execute: (...args) => {\r\n      const [_opts, newValue = void 0] = args;\r\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\r\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\r\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\r\n      }\r\n      if (nuxtApp._asyncDataPromises[key]) {\r\n        if ((opts.dedupe ?? options.dedupe) === \"defer\") {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        nuxtApp._asyncDataPromises[key].cancelled = true;\r\n      }\r\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\r\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\r\n        if (cachedData !== void 0) {\r\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\r\n          asyncData.error.value = void 0;\r\n          asyncData.status.value = \"success\";\r\n          return Promise.resolve(cachedData);\r\n        }\r\n      }\r\n      if (pendingWhenIdle) {\r\n        asyncData.pending.value = true;\r\n      }\r\n      asyncData.status.value = \"pending\";\r\n      const promise = new Promise(\r\n        (resolve, reject) => {\r\n          try {\r\n            resolve(handler(nuxtApp));\r\n          } catch (err) {\r\n            reject(err);\r\n          }\r\n        }\r\n      ).then(async (_result) => {\r\n        if (promise.cancelled) {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        let result = _result;\r\n        if (options.transform) {\r\n          result = await options.transform(_result);\r\n        }\r\n        if (options.pick) {\r\n          result = pick(result, options.pick);\r\n        }\r\n        if (import.meta.dev && import.meta.server && typeof result === \"undefined\") {\r\n          const caller = getUserCaller();\r\n          const explanation = caller ? ` (used at ${caller.source}:${caller.line}:${caller.column})` : \"\";\r\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\`) or the request may be duplicated on the client side.`);\r\n        }\r\n        nuxtApp.payload.data[key] = result;\r\n        asyncData.data.value = result;\r\n        asyncData.error.value = void 0;\r\n        asyncData.status.value = \"success\";\r\n      }).catch((error) => {\r\n        if (promise.cancelled) {\r\n          return nuxtApp._asyncDataPromises[key];\r\n        }\r\n        asyncData.error.value = createError(error);\r\n        asyncData.data.value = unref(options.default());\r\n        asyncData.status.value = \"error\";\r\n      }).finally(() => {\r\n        if (promise.cancelled) {\r\n          return;\r\n        }\r\n        if (pendingWhenIdle) {\r\n          asyncData.pending.value = false;\r\n        }\r\n        delete nuxtApp._asyncDataPromises[key];\r\n      });\r\n      nuxtApp._asyncDataPromises[key] = promise;\r\n      return nuxtApp._asyncDataPromises[key];\r\n    },\r\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\r\n    _default: options.default,\r\n    _deps: 0,\r\n    _init: true,\r\n    _hash: import.meta.dev ? createHash(_handler, options) : void 0,\r\n    _off: () => {\r\n      unsubRefreshAsyncData();\r\n      if (nuxtApp._asyncData[key]?._init) {\r\n        nuxtApp._asyncData[key]._init = false;\r\n      }\r\n      if (purgeCachedData && !hasCustomGetCachedData) {\r\n        nextTick(() => {\r\n          if (!nuxtApp._asyncData[key]?._init) {\r\n            clearNuxtDataByKey(nuxtApp, key);\r\n            asyncData.execute = () => Promise.resolve();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n  return asyncData;\r\n}\r\nconst getDefault = () => void 0;\r\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\r\n  if (nuxtApp.isHydrating) {\r\n    return nuxtApp.payload.data[key];\r\n  }\r\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\r\n    return nuxtApp.static.data[key];\r\n  }\r\n};\r\nfunction createHash(_handler, options) {\r\n  return {\r\n    handler: hash(_handler),\r\n    transform: options.transform ? hash(options.transform) : void 0,\r\n    pick: options.pick ? hash(options.pick) : void 0,\r\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\r\n  };\r\n}\r\n"],"version":3}